# Introducing the Grid View Widget

The GridView displays a two-dimensional array of widgets. Now, in our GridView demo, we're going to be using many images, so the images sub-folder inside my Flutter Project has a number of images that have placed in there, make sure that your pubspec.yaml file has an assets specification and point to your images sub-folder, Now, in this GridView demo, I'm going to do something a little different. I'm going to have my main widget within the main.dart file. This is the MyStore StatelessWidget. This MyStore StatelessWidget displays a list of products. I set the body of the scaffold to the ProductsView.But I'm going to define this ProductsView in a separate file. So, open up the left navigation pane and create a new sub-folder within the lib folder that contains the main.dart file.

I'm going to name this New Directory that I create views because this directory that I'm about to create will hold the views that I display in my app. So, I have the views directory under the lib sub-folder and under the views directory, I'm going to create a New Dart File called products.dart. This products.dart file is what will contain the widget products view which will display a GridView of products. Now, all changes that I make to my app will be to this products.dart file. I won't be changing main.dart at all. Now, in order to be able to reference this class in the main.dart file, I need to add in an import statement. Let's head back to products.dart and see how we can set up a GridView to display products. Now, the main axis of the GridView is the direction in which the GridView scrolls, which is vertical by default. I've set the crossAxisCount to be 2 to indicate that I want to display 2 grids per row. The children property of the GridView are all containers. Every container has a slightly different background and has a text field as a child which displays different product categories. For example, this first GridItem displays the product Breakfast and Dairy. And if, we scroll down,

the second GridItem displays Fresh Vegetables, and so on. I've just hardcoded a whole number of containers here that make up the different widgets displayed within my GridView. You can use the crossAxisCount to control how many grid elements you want to see in a particular grid row. 

Now, this was a very simple GridView. Let's make this GridView a little better by having the GridView display GridItem widgets.
I've updated the ProductsView class. The crossAxisCount is set to 2, that's what looked good on our device. I have a little padding around the GridView, I use List.generate to generate the items that will be displayed in this GridView. I have a variable called products which represents the products that I'm going to show. For each product, we'll instantiate a custom GridItem widget. The Product class is defined  a title and a subtitle. This List comprises of a number of different products. The title has the Product name and the subtitle has the Product category. Every Product will be displayed within a GridView using the GridItem custom widget The getRandomColor helper method generates a color at random. This is the color that we'll use as the background for each GridItem Card. I have the Widget tree for each GridItem. Every GridItem is represented using the Card Widget. I assign the color to the Card using getRandomColor so we have each Card in a different color. And then the child of this Card is a centered widget which contains a column and this column contains the product title and the product subtitle for each product.


Now, the colors for each of these cards are generated using our random object. So, if you hit hot reload each time, you'll find that the colors and the cards are different. So, if you're wondering why the colors on the cards keep changing each time you hot reload your app, well, that's the reason because the colors are being randomly generated. Well, I have quite a bit of fun playing around with these colors and that's why I tend to play around with the hot reload really often. You can scroll around and see what your GridView looks like.

I've increased the padding from 15 to 20 pixels, so you should find that there is now more space around the GridView and you can see this change in the emulator. Padding allows you to change the spacing around the GridItem from the GridView.

crossAxisSpacing will allow you to control the spacing along the cross axis. The cross axis in a vertically scrolling GridView is the horizontal axis. And you can see from the update that the horizontal elements are now further apart, they're 15 pixels apart. Cross axis always refers to the non-scrolling axis. If you want to change the spacing between the widgets on the main axis, set the mainAxisSpacing property. I've set it to 15. The main axis here is the vertical axis because our GridView scrolls vertically. Just wait for the app to be reloaded and you can see that the widgets are now placed further apart along the vertical axis. The GridView also allows you to change the scrollDirection. Set the scrollDirection property to Axis.horizontal. This will switch your GridView over, so that, you can now scroll horizontally. The main axis now is the horizontal axis and the cross axis is the vertical axis when you have a horizontally scrolling GridView.

## Displaying Images Using the GridView

I return a GridView using the GridView.count constructor. I've said this earlier, the GridView.count constructor is the easiest way to create a GridView, but there are other constructors and we'll get to those in a little bit. The crossAxisCount is 2, so we'll see two items for every row in the grid. Since, I haven't explicitly specified a scroll property, this grid will scroll vertically by default. The cross axis and mainAxisSpacing have both been set to 15 pixels. And you can see that the children of this GridView has been assigned using an array of images. I've used the spread operator here the three dots. You'll be able to see the images variable. This is merely a List of Image widgets. Every image is set to an AssetImage, that is, this is an image that is packaged into a asset bundle and part of our Flutter project. The images have been initialized and set up as a List.

Let's go ahead and run this code and take a look at our GridView that displays images. Well, this GridView looks pretty good, but the first thing that ought to strike you is that all of these images are of different shapes and different aspect ratios. We'll fix that in a bit, but before that you can see that I can just add more images to this grid view by adding more images to the list here. Now, you can see all of the images on screen, but they all have different sizes and different aspect ratios and the grid looks kind of ugly.

In order to have your images fit nicely into this grid, you need an additional fit property on the image widget. The fit says BoxFit.cover. The BoxFit enum describes how a box should be inscribed in another box. The BoxFit.cover option says keep the content as small as possible while still covering the entire target box. And when your app reloads, you'll see that all of your images are now displayed very nicely within the box of each grid element. The BoxFit.cover option for the fit property is very useful when you're building apps. Your original images are likely to be of different sizes and different aspect ratios, BoxFit.cover will lay them out evenly. Now, let's look at how we can improve our grid. Not only do I want to display images within the grid.

I want images along with text. I've set the crossAxisCount to 2. I have some padding. I use List.generate to generate a list of widgets that will be the children of this GridView. These widgets will display product information image along with text. Now, I've stored a list of products in the products variable. The number of list items will be equal to the number of products. Each product is represented using a custom widget that is the GridItem. I've instantiated the GridItem and each GridItem takes in a reference to a product. I use the Product class to represent each product. You can see that every Product has an image and a corresponding title. I've instantiated the List of Products that every Product object references an image and has a corresponding title that describes that image, Stylish heels, Laced heels, and so on. The GridItem custom widget is what I'm going to display products to screen.
The Card is just a sheet of material used to represent some related information and it can be designed to look great with elevation, rounded corners, and so on. You can use Cards within ListViews. You can use them within GridViews as well. I set a random color to the card, I set an elevation of 5, and I set its shape to have rounded corners. I set the color of the border of the Card. I use Theme.of(context) to get the color from the current context colorScheme, and I get the outline color from the current context. If you have a unifying theme across your entire application, this is how you can access specific properties from the color scheme for your theme. Let's take a look at the content of this Card. Its child is a centered column. Our product image, and I have the BoxFit.fill fit, so that, it's displayed as a nice square. And then, I have the Text widget right below it.

## Configuring GridView Properties

I'm going to use the GridView constructor. When you use this constructor, you need to specify the gridDelegate. The gridDelegate is what you use to create grid layouts with a fixed number of tiles in the cross axis. The GridView.count constructor that we've used earlier uses this gridDelegate under the hood. But when we work directly with the gridDelegate, you have much more control over how your grid is laid out. I've set the gridDelegate property to a SliverGridDelegateWithFixedCrossAxisCount. This delegate creates grids with equally sized and spaced tiles. The crossAxisCount I've set to 2. That means I'll display two elements or row. The crossAxisSpacing is 10, mainAxisSpacing is 10 and the childAspectRatio is 0.5. Remember, in a vertically scrolling grid, the main axis is the vertical axis and the cross axis is the horizontal axis. Other than explicitly specifying the gridDelegate, I haven't made any changes to what I'm displaying. You can see that I set the children of this GridView using List.generate and each GridItem will display a product, The image along with some text. I'm going to go ahead and let my app reload using hot reload and this is what the resulting grid looks like. I think the spacing is a lot better for this grid. The spacing I've specified using crossAxisSpacing and mainAxisSpacing. I've added an additional property mainAxisExtent and I've set that to 300 pixels. By default, you can see that the height and width of every item in our grid is exactly the same. The mainAxisExtent can be used to change the height of the GridView child. The main axis in a vertically scrolling grid is the vertical axis. So, mainAxisExtent will change the height of the grid child and that's exactly what you see when you hot reload. Notice that the height of every grid element has now been set to 300 pixels. The GridView element's size has changed along the main axis, the vertical axis.

Now, you may not want to specify a fixed height or width for your child within a grid view. You may want to specify an aspect ratio. The childAspectRatio of the gridDelegate is the ratio of the cross axis to the mainAxisExtent of each child. Now, when I set this to 0.5, the cross axis that is the width of each child will be 0.5, the height of each child. And when you reload, that's exactly what you see. The childAspectRatio is a great property when you want to control the look and feel without specifying specific heights or widths. You can play around with this childAspectRatio and see what suits your app. Now I've changed the childAspectRatio to be 1.2. So, the cross axis, the width will be 1.2 times the height. This doesn't look that great. But well, you'll only know what looks good if you experiment and test things out. Now, let's move on from the childAspectRatio on to some other properties of the SliverGridDelegate.



I've updated the gridDelegate property and set it to be a SliverGridDelegateWithMaxCrossAxisExtent. This is used to define the maximum width and height of the child widget in our grid. Let's say you have a vertically scrolling grid, which is what we have worked with so far. This particular gridDelegate will set the column count to vary based on the width of the devices screen. you can see that we have set the maxCrossAxisExtent to be 150 pixels. So, for a vertically scrolling grid, no child element will have a width that is greater than 150 pixels, but the width of the child elements can be smaller based on the width of the device screen. In order for you to really understand what I mean here, I'm going to run this code on our Pixel 5 device here. I'll then run it on a Chrome web browser where we'll be able to adjust the width of the device screen. Once I reload my app, you can see that the crossAxisCount has been set to 3. That is, every row now displays 3 elements. This gridDelegate will select a crossAxisExtent for the tiles that is as large as possible, so long as the extent evenly divides the crossAxisExtent of the grid displayed. Also the maxCrossAxisExtent or the width of a grid tile is 150 pixels. Our Android virtual device here is a fixed width device let's run this using the Chrome browser. So, I've selected Chrome here in my device drop-down, and I'm going to run this particular app on the Chrome browser. We'll then change the width of the screen and see how this gridDelegate behaves.

Now, here as I have widened the screen, there are more grid tiles that fit on the same row. Every grid tile will have a maximum width of 150 pixels. And as I make the screen smaller, you can see there are fewer grid tiles in the same row. When I make the browser full screen, it will try and fit as many grid tiles as possible in a single row, provided each grid tile has a crossAxisExtent that is a maximum of 150 pixels. Thus, you can specify a maxCrossAxisExtent for your tiles. And have a variable number of items per row in your grid view with this particular delegate. Now, let's take a look at some of the scrollable physics that you can configure with your GridView. I'm going to set my device back to the Pixel 5 API 30. Now, when you scroll your GridView either vertically or horizontally, you often see a little effect when you come to the very top of the scroll or when you come to the very bottom of the GridView. This effect can be controlled by setting the physics property.

I've set the physics of the scrollable portion of the GridView to be NeverScrollableScrollPhysics. This means our GridView cannot be scrolled. Now, I must admit that might not be a very useful GridView, well, but it's possible for you to set up. So, I'm going to reload the app and now I'm going to try and scroll the GridView that I have displayed. Try as I might. This GridView refuses to scroll. Well, you can make your ScrollPhysics have a slightly different effect. Instead of NeverScrollableScrollPhysics, let's change it to the BouncingScrollPhysics. So, each time you get to the beginning or the end of the GridView, there is a little bounce. I reload my application and I'm going to try out the scroll. I'm going to scroll to the bottom of the items in the GridView and try scroll past the bottom and you'll see a little bounce.